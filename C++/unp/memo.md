第五章第十节，figure 5.11，关于tcpcliserv/sigchldwaitpid.c的sig_chld()函数里的循环的理解：
上文提到，在处理一个signal时，再到来同样的signal会被阻止，所以wait()在处理5个同时结束的子进程的时候，无法正常全部处理。
而使用循环中的waitpid()可以解决。原理如下：如果在第一个子进程终结时，进入sig_chld()函数，收割该子进程；此时如果又有子进程终结，
signal会被阻止，但是此时我们正在处理第一个终结的子进程，而且处于一个循环中，所以即使没有收到第二个及可能更多的此时终结的子进程的signal，
在处理完第一个子进程后，循环的条件满足（因为仍然有未处理的已终结进程），循环继续，所以通过第一次signal的处理函数调用可以处理所有在处理函数调用期间终结的所有子进程。
如果处理完当前已终结的所有子进程，循环结束，处理函数返回。此时如果剩下的子进程终结，触发signal，会再次调用处理函数，最终全部完成处理。

之所以不能用wait在循环，是wait总会阻塞。假如在处理第一个终结子进程时没有其他子进程终结，那么处理完之后处理函数会阻塞，直到下一个子进程终结，继续处理，如此重复直到所有子进程全部处理完成。我感觉这样虽然能处理完，但是处理函数全程阻塞，问题很大。除此之外，还有问题。在最后一个子进程处理完成之后进程继续阻塞，且永远阻塞了下去。我们无法事先直到一共有多少子进程需要收割，所以不能这么做。这部分的理解不一定完全正确，回头继续学习。

# 动态库的使用

编译生成动态库，gcc编译时直接加入动态库文件，运行正常；通过-l命令加入动态库，则需要同时通过-L命令给出我们自己动态库所在的目录，否则会链接错误。但是这样还不够，虽然编译链接没有报错，运行最终使用改库的程序是会报错，找不到库文件。我们需要修改/etc/ld.so.conf.d/libc.conf文件，将我们的动态库所在目录加入其中，保存修改后，运行ldconfig。此时再运行通过-l方式链接动态库的程序即正常运行。